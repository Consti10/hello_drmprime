//da->fb_handle=de->drm_fd;
    //    void *dev=NULL;
    //    ret=drmModePageFlip(de->drm_fd,de->setup.crtcId,da->fb_handle,
    //                        0, nullptr);


#if 1 && TRACE_ALL
        fprintf(stderr, "%dx%d, fmt: %x, boh=%d,%d,%d,%d, pitch=%d,%d,%d,%d,"
               " offset=%d,%d,%d,%d, mod=%llx,%llx,%llx,%llx\n",
               av_frame_cropped_width(frame),
               av_frame_cropped_height(frame),
               desc->layers[0].format,
               bo_handles[0],
               bo_handles[1],
               bo_handles[2],
               bo_handles[3],
               pitches[0],
               pitches[1],
               pitches[2],
               pitches[3],
               offsets[0],
               offsets[1],
               offsets[2],
               offsets[3],
               (long long)modifiers[0],
               (long long)modifiers[1],
               (long long)modifiers[2],
               (long long)modifiers[3]
              );
#endif


 &da->fb_handle, DRM_MODE_FB_MODIFIERS /** 0 if no mods */) != 0) {

/*XAVFrame *frame;

        do_sem_wait(&de->q_sem_in, 0);

        if (de->q_terminate)
            break;

        frame = de->q_next;
        de->q_next = NULL;
        avgDisplayThreadQueueLatency.addUs(getTimeUs()-frame->pts);
        avgDisplayThreadQueueLatency.printInIntervals(CALCULATOR_LOG_INTERVAL);
        //frame->pts=getTimeUs();
        sem_post(&de->q_sem_out);

        do_display(de, frame);*/
        /*if (de->q_terminate)
            break;
        auto tmp=de->queue.popIfAvailable();
        if(tmp){
            do_display(de,tmp->frame);
        }*/

/*Xret = do_sem_wait(&de->q_sem_out, !de->show_all);
    if (ret) {
        av_frame_free(&frame);
    } else {
        de->q_next = frame;
        sem_post(&de->q_sem_in);
    }*/

// get the most recently added element (if there is any)
    // and then reduce the queue size to 0
    std::shared_ptr<T> getMostRecentIfAvailable(int& countDropped){
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty()) {
            return std::shared_ptr<T>(nullptr);
        }
        auto tmp=queue_.back();
        while(!queue_.empty()) {
            queue_.pop();
            countDropped++;
        }
        return tmp;
    }


/*for (int k = 0; k < width; ++k) {
            const int off = offsetStride + k * 4;
            *(uint32_t*)&dest[off] =rgb;
        }*/