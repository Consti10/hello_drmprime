//da->fb_handle=de->drm_fd;
    //    void *dev=NULL;
    //    ret=drmModePageFlip(de->drm_fd,de->setup.crtcId,da->fb_handle,
    //                        0, nullptr);


#if 1 && TRACE_ALL
        fprintf(stderr, "%dx%d, fmt: %x, boh=%d,%d,%d,%d, pitch=%d,%d,%d,%d,"
               " offset=%d,%d,%d,%d, mod=%llx,%llx,%llx,%llx\n",
               av_frame_cropped_width(frame),
               av_frame_cropped_height(frame),
               desc->layers[0].format,
               bo_handles[0],
               bo_handles[1],
               bo_handles[2],
               bo_handles[3],
               pitches[0],
               pitches[1],
               pitches[2],
               pitches[3],
               offsets[0],
               offsets[1],
               offsets[2],
               offsets[3],
               (long long)modifiers[0],
               (long long)modifiers[1],
               (long long)modifiers[2],
               (long long)modifiers[3]
              );
#endif


 &da->fb_handle, DRM_MODE_FB_MODIFIERS /** 0 if no mods */) != 0) {

/*XAVFrame *frame;

        do_sem_wait(&de->q_sem_in, 0);

        if (de->q_terminate)
            break;

        frame = de->q_next;
        de->q_next = NULL;
        avgDisplayThreadQueueLatency.addUs(getTimeUs()-frame->pts);
        avgDisplayThreadQueueLatency.printInIntervals(CALCULATOR_LOG_INTERVAL);
        //frame->pts=getTimeUs();
        sem_post(&de->q_sem_out);

        do_display(de, frame);*/
        /*if (de->q_terminate)
            break;
        auto tmp=de->queue.popIfAvailable();
        if(tmp){
            do_display(de,tmp->frame);
        }*/

/*Xret = do_sem_wait(&de->q_sem_out, !de->show_all);
    if (ret) {
        av_frame_free(&frame);
    } else {
        de->q_next = frame;
        sem_post(&de->q_sem_in);
    }*/

// get the most recently added element (if there is any)
    // and then reduce the queue size to 0
    std::shared_ptr<T> getMostRecentIfAvailable(int& countDropped){
        std::lock_guard<std::mutex> lock(mutex_);
        if (queue_.empty()) {
            return std::shared_ptr<T>(nullptr);
        }
        auto tmp=queue_.back();
        while(!queue_.empty()) {
            queue_.pop();
            countDropped++;
        }
        return tmp;
    }


/*for (int k = 0; k < width; ++k) {
            const int off = offsetStride + k * 4;
            *(uint32_t*)&dest[off] =rgb;
        }*/

// This was in the original code, but it won't have an effect anyways since swapping the fb aparently does VSYNC anyways nowadays
static void waitForVSYNC(DRMPrimeOut *const de){
    chronoVsync.start();
    drmVBlank vbl = {
            .request = {
                    // Consti10: I think to get the next VBLANK, we need to set sequence to 1
                    // https://docs.nvidia.com/jetson/l4t-graphics/group__direct__rendering__manager.html#gadc9d79f4d0195e60d0f8c9665da5d8b2
                    .type = DRM_VBLANK_RELATIVE,
                    //.sequence = 0
                    .sequence = 1
            }
    };
    /*while (drmWaitVBlank(de->drm_fd, &vbl)) {
        if (errno != EINTR) {
            // This always fails - don't know why
            //fprintf(stderr, "drmWaitVBlank failed: %s\n", ERRSTR);
            break;
        }
    }*/
    const int ret=drmWaitVBlank(de->drm_fd,&vbl);
    if(ret!=0){
        fprintf(stderr, "drmWaitVBlank failed:%d  %s\n",ret, ERRSTR);
    }
    chronoVsync.stop();
    chronoVsync.printInIntervals(CALCULATOR_LOG_INTERVAL);
}

//static void consti10_copy_into_curr_fb(drmprime_out_env_t *const de,AVFrame* frame,drm_aux_t *da){
//}
/*static void consti10_page_flip(drmprime_out_env_t *const de,drm_aux_t *da,AVFrame *frame){
    if (drmPrimeFDToHandle(de->drm_fd, desc->objects[0].fd, da->bo_handles) != 0) {
        fprintf(stderr, "drmPrimeFDToHandle[%d](%d) failed: %s\n", 0, desc->objects[0].fd, ERRSTR);
        return -1;
    }

    drmModePageFlip(de->drm_fd,de->setup.crtcId,da->fb_handle,DRM_MODE_PAGE_FLIP_EVENT | DRM_MODE_PAGE_FLIP_ASYNC,de);
}*/
if (mXOptions.deinterlace) {
        if (init_filters(video, decoder_ctx, "deinterlace_v4l2m2m") < 0) {
            fprintf(stderr, "Failed to init deinterlace\n");
            return -1;
        }
    }

if(countLol>20){
        fprintf(stderr,"de->setup.crtcId: %d da->fb_handle: %d",de->setup.crtcId,da->fb_handle);
        // https://github.com/raspberrypi/linux/blob/aeaa2460db088fb2c97ae56dec6d7d0058c68294/drivers/gpu/drm/drm_ioctl.c#L686
        // https://github.com/raspberrypi/linux/blob/rpi-5.10.y/drivers/gpu/drm/drm_plane.c#L1044
        //DRM_MODE_PAGE_FLIP_EVENT
        /*if(drmModePageFlip(de->drm_fd,de->setup.crtcId,da->fb_handle,0,de)!=0){
            fprintf(stderr, "drmModePageFlip failed: %s %d\n", ERRSTR, errno);
            return -1;
        }else{
            fprintf(stderr, "drmModePageFlip success\n");
        }*/
        drmModeConnectorPtr xConnector=drmModeGetConnector(de->drm_fd,de->setup.conId);
        MLOGD<<"de->con_id:"<<de->con_id<<" de->setup.conId"<<de->setup.conId<<" actual connector"<<xConnector<<"\n";
        uint32_t connectors[1];
        connectors[0]=(uint32_t)de->con_id;
        if(drmModeSetCrtc(de->drm_fd,de->setup.crtcId,da->fb_handle,0,0,connectors,1,NULL)!=0){
            fprintf(stderr, "drmModeSetCrtc failed: %s %d\n", ERRSTR, errno);
        }else{
            fprintf(stderr, "drmModeSetCrtc success\n");
        }
    }else{